---
title: "Analisando dados da GooglePlayStore"
author: "Renan Tomazini"
date: '22 setembro de 2022'
output:
  prettydoc::html_pretty:
    theme: architect  
    highlight: github
---
# O projeto {.tabset}

Para esse projeto estarei analisando o conjunto de dados de Downloads e avaliações de aplicativos da GooglePlayStore obtidos em Julho de 2022.

<img src="images/google-play-logo-2.jpg" alt="drawing" style="width:200px; display: block;margin-left: auto;margin-right: auto;"/>


# Introdução

O conjunto de dados analisados trata-se de um compilado dos aplicativos mais populares da _GooglePlayStore_, com detalhes sobe sua categoria, preço, número de Downloads, avaliações, número de Reviews, tamanho, gênero e público alvo.
O objetivo é verificar os aplicativos mais populares de cada categoria, se existe alguma relação entre suas avaliações, seu preço e público alvo. Com esses dados podemos verificar quais aplicativos tem têndencia de serem mais populares e quais despertam maior interesse no público e assim ter uma segurança maior ao desenvolver aplicativos para plataforma, verificando quais são os concorrentes, suas avaliações e quais os serviços mais populares.

## Pacotes Requeridos
Os pacotes a serem usados são:

### plotly
Para criação de gráficos.

### stringr
Para trabalhar com as strings presentes no dataset.

### tidyr
Para auxiliar na limpeza e organização das tabelas de dados.

### prettydoc
Personalização do tema para melhor visualização do documento.

``` {r blibiotecas, message = FALSE} 
#pacotes a serem importados

library(prettydoc)
library(plotly)
library(stringr)
library(tidyr)
library(plyr)

```

## Preparação dos dados

### Fonte dos dados
Os dados foram retirados do agregador [kaggle](https://www.kaggle.com/datasets/adityagupta152002/google-play). A principio eles são apenas um conjunto de dados de dominio público retirados da GooglePlay Store via mineração de texto, com alguns dados corrompidos, não normalizados ou faltando. 
 O conjunto de dados de Downloads e avaliações de aplicativos da GooglePlayStore foram obtidos em Julho de 2022.
 
``` {r dados}
dados <- read.csv("googleplaystore.csv")

#head(dados)

```
 
### Limpeza de dados
Aqui farei a limpeza dos dados faltando, não normalizados ou corrompidos.

#### Irei ignorar os casos não completos primeiramente
```{r limpeza_casos_incompletos}
#is.na(dados$Rating)
df <- dados[complete.cases(dados), ]
#head(df)

print(paste0("Número de dados completos: ",nrow(df)))

```

#### Irei retirar dados percebidos como fora do padrão em rating:
```{r rating}
df[df$Rating > 5,] <- 5
df[df$Rating < 0,] <- 0



```

#### substituir os dados de número de instalações de string para números, eles são arredondados e aproximados pelo próprio Google
``` {r numero_instalacao}
#Verifiquei abaixo as possibilidades antes de substituir
#unique(df$Installs)

df$Installs[df$Installs == "10,000+"] <- 10000
df$Installs[df$Installs == "500,000+"] <- 500000
df$Installs[df$Installs == "5,000,000+"] <- 500000
df$Installs[df$Installs == "50,000,000+"] <- 5000000
df$Installs[df$Installs == "100,000+"] <- 100000
df$Installs[df$Installs == "50,000+"] <- 50000
df$Installs[df$Installs == "1,000,000+"] <- 1000000
df$Installs[df$Installs == "10,000,000+"] <- 10000000
df$Installs[df$Installs == "5,000+"] <- 5000
df$Installs[df$Installs == "100,000,000+"] <- 100000000
df$Installs[df$Installs == "1,000,000,000+"] <- 1000000000
df$Installs[df$Installs == "1,000+"] <- 1000
df$Installs[df$Installs == "500,000,000+"] <- 500000000
df$Installs[df$Installs == "100+"] <- 100
df$Installs[df$Installs == "500+"] <- 500
df$Installs[df$Installs == "10+"] <- 10
df$Installs[df$Installs == "5+"] <- 5
df$Installs[df$Installs == "50+"] <- 50
df$Installs[df$Installs == "1+"] <- 1
df$Installs[df$Installs == "5"] <- 5

df$Type[df$Installs == "5"] <- "Paid"


df$Reviews <- as.integer(as.character(df$Reviews)) #convertendo o numero de reviews para int afim de usar os dados

#head(df)


```



### Como está o conjunto limpo
Os dados limpos e normalizados estão aqui, aqui são uma amostra com o top25 dos melhores avaliados com maior número de reviews.

``` {r amostra}

#head(df)
dfOrdenado <-df[order(-df$Rating, -df$Reviews),]

top25 <- dfOrdenado[1:25,]

plot_ly( type='table',
        #collumnwidth= c(50,50),
        #collumnorder= c(0,1),
        header = list(
          values =c("App", "Rating"),
          align= c("center","center"),
          fill = list(color = c("#9ddcff", "#317ccf")),
          line= list(width= 1.5, color = 'black'),font= list(family= "Helvetica", size= 12, color = c("black"))
        ),
        cells =list(
          values = rbind(top25$App, top25$Rating),
          align= c("center","center"),
          line= list(width= 1.5, color = 'black'),font= list(family= "Helvetica", size= 12, color = c("black"))
        )
        )%>% layout(title = "25 Aplicativos melhores avaliados com maior numero de review")

```




## Análise exploratória dos dados
Exploro os dados a partir daqui

### Categorias mais bem avaliadas
Aqui serão analisadas as categorias com melhor rating dos usuários e se há diferença entre elas se forem pagas ou não.
``` {r amostra}

#head(df)
dfOrdenado <-df[order(-df$Rating, -df$Reviews),]

top1000 <- dfOrdenado[1:1000,]
top100 <- top1000[1:100,]

ContagemTypeGeral <- count(dfOrdenado,'Type')
ContagemTypeGeral$perc <- c(top1000ContagemType[,2] / length(dfOrdenado$App)*10)
colnames(top1000ContagemType)<- c("Type","freq","perc")


#dfOrdenado$Type
top1000ContagemType <- count(top1000,'Type')
top1000ContagemType$perc <- c(top1000ContagemType[,2] / length(top1000$App))
colnames(top1000ContagemType)<- c("Type1000","freq1000","perc1000")

top100ContagemType <- count(top100,'Type')
top100ContagemType$perc <- c(top100ContagemType[,2] / length(top100$App))
colnames(top100ContagemType)<- c("Type100","freq100","perc100")





fig <- plot_ly(ContagemTypeGeral, x = ~Type, y = ~perc, type = 'bar', name = 'Porcentagem geral')



fig <- fig %>%  add_trace(top1000ContagemType, x = ~top1000ContagemType$Type1000, y = ~top1000ContagemType$perc1000, type = 'bar', name = 'Porcentagem 1000 primeiros')


fig <- fig %>% add_trace(top100ContagemType,
                         x =top100ContagemType$Type100,
        y = ~top100ContagemType$perc100,
        type = 'bar',
        name = "Porcentagem 100 primeiros")

fig <- fig %>% layout(yaxis = list(title = 'Count'), barmode = 'stack')        
  



fig
```


### Mais populares por público alvo
Quais categorias de aplicativo são mais populares por público alvo (idade), se eles são pagos ou não e buscar quais as formas de financiamento dos 10 aplicativos mais populares de cada público alvo.

## Conclusões
Aqui vão ficar as _conclusões_ quando eu tiver alguma


## Formatação e Outros Requisitos

6.1 O estilo adequado de codificação deve ser seguido e o código deve serbem comentado. 6.2 A codificação deve ser sistemática -problemascomplicadosdevem ser divididosem subproblemas que são individualmente muito mais simplesde serem resolvidos. O código deve ser8
eficiente, correto e mínimo. Ele também precisausarestruturasde dados apropriadas (lista, data frame, vetor, matriz e fatores). 6.3Realização, domínio, esperteza ecriatividade: As ferramentas e técnicas do curso devem seraplicadas de forma competente e, talvez, de alguma forma criativa. 6.4 Ir além do que era esperado e requeridoatravés douso de pacotes, ferramentas e métodos não abordados pelo curso.